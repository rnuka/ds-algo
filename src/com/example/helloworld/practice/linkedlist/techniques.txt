1. Slow runner / fast runner approach
   a. Kth node from last
   b. to find middle element in the linked list
   c. to detect the loop in the list
   
   while(fast != null && fast.next != null){
      if(slow == fast) return;
      slow = slow.next; fast = fast.next.next;
   }

2. Merge two linked lists- find interesection point. Find len1, len2 of two lists and advance one to ~(len1-len2) and find intersection
   l1Len = len(l1); l2Len = len(l2);
   if(l1Len > l2len) {  l1 = advanceList(l1Len - l2Len, l1) }  else  { l2 = advanceList(l2Len - l1Len, l2); }
   while(l1 != null && l2 != null && l1 != l2)  { l1 = l1.next; l2 = l2.next;}
   return l1;
   
3. Reversing a linked list
    a. reverse every k nodes in a list (use recursion and come from the last)
    reverse(Node root)
      Node prev = null, next = curr = root;
      while(curr != null){
         next = curr.next;
         curr.next = prev;
         prev = curr;
         curr = next;
      }

4. Merge two sorted lists
   Node dummyHead = new Node(0); Node curr = dummyHead; Node p1, p2;
   while(p1 != null && p2 != null){
      if(p1.data <= p2.data){ curr.next = p1; p1 = p1.next;}
      else { curr.next = p2; p2 = p2.next;}
      curr = curr.next;
   }
   curr.next =  (p1 != null) ? p1 : p2;
   return dummyHead.next; //dummyHead is like sentinel
